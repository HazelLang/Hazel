# Special Tokens
EOF,        # EOF
ERROR,      
COMMENT,    # //
WHITESPACE, # '\n  \t'
IDENTIFIER, # foo, bar 
AT_SIGN,    # @
COMMA,      # ,
SEMICOLON,  # ;

# Keywords
KEYWORD, 
BEGIN, 
BREAK, 
CASE,
CATCH, 
CONST,
CONTINUE, 
DO, 
DEF,
DEFAULT, 
ELSE,
ELSEIF, 
END, 
EXPORT, 
FINALLY, 
FOR,
# GLOBAL # ==> not required tbh coz we follow a no-globals approach
IF,
IMPORT,
INCLUDE,
MACRO,
MATCH, # similar to 'switch' in C++, Java and others
MODULE,
MUTABLE,
# NEW # ==> if we go for a memory-safety approach like Rust
RANGE,
RETURN, 
STRUCT, 
TRY, 
TYPE, 
USE,
WHERE, 
WHILE,

# cstparser
INVISIBLE_BRACKETS,
NOTHING,
WS, 
SEMICOLON_WS,
NEWLINE_WS,
EMPTY_WS, 

# Literals
LITERAL,        # general
INTEGER,        # 2
BIN_INT,        # 0b1
HEX_INT,        # 0x0
FLOAT,          # 5.3, 2.6e+3
STRING,         # "foo" or 'bar'
IMAG,           # 123.45i
TRIPLE_STRING,  # """ foobar \n """
CHAR,           # 'c'
TRUE, 
FALSE,

# Operators 
ADD,            # +
SUB,            # - 
MUTLIPLICATION, # ×
QUOTIENT,       # /
REM,            # %

AND,       # &
OR,        # |
NOT,       # !
XOR,       # ^
AND_NOT,   # &^
LAND,      # && 
LOR,       # || 
INCREMENT, # ++
DECREMENT, # --

# Comparison
GREATER,                  # > 
LESS,                     # <
GREATER_THAN,             # >=
GREATER_THAN_OR_EQUAL_TO, # ≥
LESS_THAN,                # <=
LESS_THAN_OR_EQUAL_TO,    # ≤
DOUBLEEQUALS,             # == 
NOT_EQUALS,               # !=
NOT_EQUAL_TO,             # ≠
IN,                       # in
ISA,                      # isa

# Delimiters
LBRACK,  # [
RBRACK,  # ]
LBRACE,  # {
RBRACE,  # }
LPAREN,  # (
RPAREN,  # )

# Assignments
EQUALS,           # = 
PLUS_EQUALS,      # +=
MINUS_EQUALS,     # -=
START_EQUALS,     # *=
OR_EQUALS,        # |=
DIVISION_EQUALS,  # ÷=
FWD_SLASH_EQUALS, # /=
REM_EQUALS,       # %=
LBITSHIFT_EQUALS, # <<=
RBITSHIFT_EQUALS, # >>=
AND_EQUALS,       # &=
APPROX,           # ~ 

# Colons
COLON,    # :
DOT,      # .
DDOT,     # ..
ELLIPSIS, # ...

# Bitshifts
LBITSHIFT, # << 
RBITSHIFT, # >> 

# Conditional
CONDITIONAL, # ? 

# Arrows
PAIR_ARROWS,                  # =>
ANON_FUNC,                    # -> 
# RIGHT_ARROW,         # -> # DEFINED AS ANON_FUNC
LEFT_ARROW,                   # <-
LEFTWARDS_ARROW,              # ←
RIGHTWARDS_ARROW,             # →
HALFWIDTH_LEFTWARDS_ARROW,    # ￩
HALFWIDTH_RIGHTWARDS_ARROW,   # ￫
LONG_LEFTWARDS_ARROW,         # ⟵
LONG_RIGHTWARDS_ARROW,        # ⟶ 

# Declaration (we might/might not use this)
DECLARATION, # :: 